#!/usr/bin/env python3
"""
Cymatic Explorer - Automated Resonance Detection with Visual Interface
A minimal, radio-dial style interface for exploring the frequency space
"""

import tkinter as tk
from tkinter import ttk
import numpy as np
import math
import time
import threading
from queue import Queue
from resonance_detector import ResonanceDetector, FrequencyScanner

class CymaticExplorer:
    def __init__(self, root):
        self.root = root
        self.root.title("Cymatic Explorer - Resonance Detector")
        self.root.geometry("1200x800")
        self.root.configure(bg='#000011')
        
        # Detection system
        self.detector = ResonanceDetector()
        self.scanner = FrequencyScanner(self.detector)
        
        # Visual state
        self.running = False
        self.pattern_history = []
        self.signal_buffer = np.zeros(800)  # Circular buffer for display
        self.buffer_index = 0
        
        # Performance optimization
        self.last_draw_time = 0
        self.fps_limit = 30  # 30 FPS max
        self.frame_skip = 0
        
        # Thread communication
        self.pattern_queue = Queue()
        self.detection_thread = None
        
        self.setup_ui()
        self.start_detection()
        
    def setup_ui(self):
        """Create minimal, radio-dial style interface"""
        
        # Main display area
        display_frame = tk.Frame(self.root, bg='#000011')
        display_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Large oscilloscope display
        self.canvas = tk.Canvas(display_frame, bg='#001122', highlightthickness=0)
        self.canvas.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        
        # Control panel (minimal radio-style)
        control_frame = tk.Frame(display_frame, bg='#000011', height=120)
        control_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(20, 0))
        control_frame.pack_propagate(False)
        
        # Left side - Radio dial style controls
        dial_frame = tk.Frame(control_frame, bg='#000011')
        dial_frame.pack(side=tk.LEFT, fill=tk.Y)
        
        # Power button
        self.power_button = tk.Button(dial_frame, text="POWER", 
                                    command=self.toggle_power,
                                    bg='#003300', fg='#00ff00',
                                    font=('Courier', 14, 'bold'),
                                    width=8, height=2)\n        self.power_button.pack(pady=10)\n        \n        # Frequency display (like old radio)\n        freq_display_frame = tk.Frame(dial_frame, bg='#000011')\n        freq_display_frame.pack(pady=10)\n        \n        tk.Label(freq_display_frame, text=\"FREQUENCY\", \n                bg='#000011', fg='#00ff00', \n                font=('Courier', 8)).pack()\n        \n        self.freq_display = tk.Label(freq_display_frame, \n                                    text=\"0.00 Hz\",\n                                    bg='#001100', fg='#00ff00',\n                                    font=('Courier', 16, 'bold'),\n                                    width=12, relief=tk.SUNKEN)\n        self.freq_display.pack()\n        \n        # Scan speed control\n        speed_frame = tk.Frame(dial_frame, bg='#000011')\n        speed_frame.pack(pady=10)\n        \n        tk.Label(speed_frame, text=\"SCAN SPEED\", \n                bg='#000011', fg='#00ff00', \n                font=('Courier', 8)).pack()\n        \n        self.speed_var = tk.DoubleVar(value=0.1)\n        self.speed_scale = tk.Scale(speed_frame, from_=0.01, to=1.0, resolution=0.01,\n                                  orient=tk.HORIZONTAL, variable=self.speed_var,\n                                  bg='#000011', fg='#00ff00', \n                                  highlightbackground='#000011', length=120)\n        self.speed_scale.pack()\n        \n        # Right side - Pattern log\n        log_frame = tk.Frame(control_frame, bg='#000011')\n        log_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(20, 0))\n        \n        tk.Label(log_frame, text=\"DETECTED PATTERNS\", \n                bg='#000011', fg='#00ff00', \n                font=('Courier', 10, 'bold')).pack()\n        \n        # Pattern log with scrollbar\n        log_container = tk.Frame(log_frame, bg='#000011')\n        log_container.pack(fill=tk.BOTH, expand=True, pady=5)\n        \n        scrollbar = tk.Scrollbar(log_container)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        self.pattern_log = tk.Listbox(log_container, \n                                    bg='#001100', fg='#00ff00',\n                                    font=('Courier', 8),\n                                    yscrollcommand=scrollbar.set,\n                                    selectbackground='#003300')\n        self.pattern_log.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        scrollbar.config(command=self.pattern_log.yview)\n        \n        # Status indicators\n        status_frame = tk.Frame(control_frame, bg='#000011')\n        status_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=(20, 0))\n        \n        self.status_labels = {}\n        \n        # Scanning indicator\n        scan_frame = tk.Frame(status_frame, bg='#000011')\n        scan_frame.pack(pady=5)\n        \n        tk.Label(scan_frame, text=\"SCAN\", bg='#000011', fg='#00ff00', \n                font=('Courier', 8)).pack()\n        self.status_labels['scan'] = tk.Label(scan_frame, text=\"●\", \n                                            bg='#000011', fg='#ff0000', \n                                            font=('Courier', 16))\n        self.status_labels['scan'].pack()\n        \n        # Lock indicator\n        lock_frame = tk.Frame(status_frame, bg='#000011')\n        lock_frame.pack(pady=5)\n        \n        tk.Label(lock_frame, text=\"LOCK\", bg='#000011', fg='#00ff00', \n                font=('Courier', 8)).pack()\n        self.status_labels['lock'] = tk.Label(lock_frame, text=\"●\", \n                                            bg='#000011', fg='#ff0000', \n                                            font=('Courier', 16))\n        self.status_labels['lock'].pack()\n        \n        # Beauty meter\n        beauty_frame = tk.Frame(status_frame, bg='#000011')\n        beauty_frame.pack(pady=5)\n        \n        tk.Label(beauty_frame, text=\"BEAUTY\", bg='#000011', fg='#00ff00', \n                font=('Courier', 8)).pack()\n        self.beauty_meter = tk.Canvas(beauty_frame, width=30, height=100, \n                                    bg='#001100', highlightthickness=0)\n        self.beauty_meter.pack()\n        \n    def toggle_power(self):\n        \"\"\"Toggle the scanner on/off\"\"\"\n        self.running = not self.running\n        \n        if self.running:\n            self.power_button.config(text=\"POWER\", bg='#330000', fg='#ff0000')\n            self.status_labels['scan'].config(fg='#00ff00')\n        else:\n            self.power_button.config(text=\"POWER\", bg='#003300', fg='#00ff00')\n            self.status_labels['scan'].config(fg='#ff0000')\n            self.status_labels['lock'].config(fg='#ff0000')\n    \n    def start_detection(self):\n        \"\"\"Start the detection thread\"\"\"\n        self.detection_thread = threading.Thread(target=self.detection_loop, daemon=True)\n        self.detection_thread.start()\n        \n        # Start visual update loop\n        self.update_display()\n    \n    def detection_loop(self):\n        \"\"\"Background thread for pattern detection\"\"\"\n        while True:\n            if self.running:\n                # Update scan speed\n                self.scanner.scan_speed = self.speed_var.get()\n                \n                # Update scanner\n                pattern = self.scanner.update_scan()\n                \n                # Get current signal for display\n                signal, frequencies = self.scanner.generate_signal(0.1)\n                \n                # Queue updates for main thread\n                self.pattern_queue.put({\n                    'signal': signal,\n                    'frequencies': frequencies,\n                    'pattern': pattern,\n                    'locked': self.scanner.locked_pattern is not None\n                })\n            \n            time.sleep(0.03)  # ~33 FPS detection rate\n    \n    def update_display(self):\n        \"\"\"Update the visual display\"\"\"\n        current_time = time.time()\n        \n        # FPS limiting\n        if current_time - self.last_draw_time < 1.0 / self.fps_limit:\n            self.root.after(16, self.update_display)  # ~60 FPS check rate\n            return\n        \n        # Process queued updates\n        while not self.pattern_queue.empty():\n            try:\n                update = self.pattern_queue.get_nowait()\n                self.process_update(update)\n            except:\n                break\n        \n        # Draw the oscilloscope display\n        if self.running:\n            self.draw_oscilloscope()\n        \n        self.last_draw_time = current_time\n        self.root.after(16, self.update_display)\n    \n    def process_update(self, update):\n        \"\"\"Process an update from the detection thread\"\"\"\n        # Update signal buffer (circular buffer for smooth scrolling)\n        signal = update['signal']\n        chunk_size = min(len(signal), len(self.signal_buffer) // 4)\n        \n        if chunk_size > 0:\n            # Add new data to circular buffer\n            end_idx = (self.buffer_index + chunk_size) % len(self.signal_buffer)\n            if end_idx > self.buffer_index:\n                self.signal_buffer[self.buffer_index:end_idx] = signal[:chunk_size]\n            else:\n                # Wrap around\n                first_part = len(self.signal_buffer) - self.buffer_index\n                self.signal_buffer[self.buffer_index:] = signal[:first_part]\n                self.signal_buffer[:end_idx] = signal[first_part:chunk_size]\n            \n            self.buffer_index = end_idx\n        \n        # Update frequency display\n        avg_freq = np.mean(update['frequencies'])\n        self.freq_display.config(text=f\"{avg_freq:.2f} Hz\")\n        \n        # Update lock indicator\n        if update['locked']:\n            self.status_labels['lock'].config(fg='#ffff00')  # Yellow when locked\n        else:\n            self.status_labels['lock'].config(fg='#ff0000')  # Red when scanning\n        \n        # Log new patterns\n        if update['pattern']:\n            self.pattern_history.append(update['pattern'])\n            \n            # Add to visual log\n            pattern_str = f\"{len(self.pattern_history):02d}: {update['pattern'].pattern_type} ({update['pattern'].beauty_score:.3f})\"\n            self.pattern_log.insert(tk.END, pattern_str)\n            self.pattern_log.see(tk.END)\n            \n            # Update beauty meter\n            self.update_beauty_meter(update['pattern'].beauty_score)\n    \n    def draw_oscilloscope(self):\n        \"\"\"Draw the high-performance oscilloscope display\"\"\"\n        self.canvas.delete(\"all\")\n        \n        width = self.canvas.winfo_width()\n        height = self.canvas.winfo_height()\n        \n        if width <= 1 or height <= 1:\n            return\n        \n        # Draw grid (minimal)\n        self.draw_grid(width, height)\n        \n        # Draw waveform from circular buffer\n        self.draw_waveform(width, height)\n        \n        # Draw frequency spectrum (small)\n        self.draw_spectrum(width, height)\n    \n    def draw_grid(self, width, height):\n        \"\"\"Draw minimal oscilloscope grid\"\"\"\n        # Center lines\n        self.canvas.create_line(0, height//2, width, height//2, fill='#003366', width=1)\n        self.canvas.create_line(width//2, 0, width//2, height, fill='#003366', width=1)\n        \n        # Grid lines (very subtle)\n        for i in range(1, 4):\n            y = height * i / 4\n            self.canvas.create_line(0, y, width, y, fill='#001122', width=1)\n        \n        for i in range(1, 8):\n            x = width * i / 8\n            self.canvas.create_line(x, 0, x, height, fill='#001122', width=1)\n    \n    def draw_waveform(self, width, height):\n        \"\"\"Draw the main waveform with high performance\"\"\"\n        if len(self.signal_buffer) == 0:\n            return\n        \n        # Get data from circular buffer in correct order\n        ordered_signal = np.concatenate([\n            self.signal_buffer[self.buffer_index:],\n            self.signal_buffer[:self.buffer_index]\n        ])\n        \n        # Downsample for display if needed\n        display_points = min(width, len(ordered_signal))\n        if len(ordered_signal) > display_points:\n            indices = np.linspace(0, len(ordered_signal)-1, display_points, dtype=int)\n            display_signal = ordered_signal[indices]\n        else:\n            display_signal = ordered_signal\n        \n        # Normalize and convert to screen coordinates\n        if len(display_signal) > 0:\n            max_val = max(abs(np.max(display_signal)), abs(np.min(display_signal)), 1e-6)\n            normalized_signal = display_signal / max_val\n            \n            center_y = height // 2\n            scale = (height // 2 - 20)\n            \n            # Create line points\n            points = []\n            for i, val in enumerate(normalized_signal):\n                x = i * width / len(normalized_signal)\n                y = center_y - val * scale\n                points.extend([x, y])\n            \n            if len(points) >= 4:\n                self.canvas.create_line(points, fill='#00ff88', width=2, smooth=True)\n    \n    def draw_spectrum(self, width, height):\n        \"\"\"Draw a small frequency spectrum in corner\"\"\"\n        if len(self.signal_buffer) == 0:\n            return\n        \n        # Small spectrum display in top-right\n        spec_width = 200\n        spec_height = 100\n        spec_x = width - spec_width - 10\n        spec_y = 10\n        \n        # Background\n        self.canvas.create_rectangle(spec_x, spec_y, spec_x + spec_width, spec_y + spec_height,\n                                   fill='#000022', outline='#003366')\n        \n        # Get recent signal for FFT\n        recent_signal = self.signal_buffer[max(0, self.buffer_index-256):self.buffer_index]\n        if len(recent_signal) > 32:\n            # Simple FFT\n            fft = np.fft.fft(recent_signal)\n            power_spectrum = np.abs(fft[:len(fft)//2])\n            \n            if len(power_spectrum) > 0 and np.max(power_spectrum) > 0:\n                power_spectrum = power_spectrum / np.max(power_spectrum)\n                \n                # Draw spectrum bars\n                bar_width = spec_width / len(power_spectrum)\n                for i, val in enumerate(power_spectrum):\n                    if val > 0.1:  # Only draw significant components\n                        bar_height = val * spec_height\n                        x1 = spec_x + i * bar_width\n                        y1 = spec_y + spec_height - bar_height\n                        y2 = spec_y + spec_height\n                        \n                        self.canvas.create_rectangle(x1, y1, x1 + bar_width, y2,\n                                                   fill='#0088ff', outline='')\n    \n    def update_beauty_meter(self, beauty_score):\n        \"\"\"Update the beauty meter display\"\"\"\n        self.beauty_meter.delete(\"all\")\n        \n        meter_height = 100\n        meter_width = 30\n        \n        # Background\n        self.beauty_meter.create_rectangle(0, 0, meter_width, meter_height,\n                                         fill='#001100', outline='#003300')\n        \n        # Beauty level\n        fill_height = int(beauty_score * meter_height)\n        if fill_height > 0:\n            # Color gradient based on beauty score\n            if beauty_score < 0.3:\n                color = '#ff0000'  # Red - low beauty\n            elif beauty_score < 0.7:\n                color = '#ffff00'  # Yellow - medium beauty\n            else:\n                color = '#00ff00'  # Green - high beauty\n            \n            self.beauty_meter.create_rectangle(2, meter_height - fill_height, \n                                             meter_width - 2, meter_height - 2,\n                                             fill=color, outline='')\n        \n        # Scale marks\n        for i in range(5):\n            y = meter_height - (i * meter_height / 4)\n            self.beauty_meter.create_line(0, y, 5, y, fill='#003300')\n\ndef main():\n    root = tk.Tk()\n    app = CymaticExplorer(root)\n    \n    try:\n        root.mainloop()\n    except KeyboardInterrupt:\n        print(\"\\nExiting Cymatic Explorer...\")\n\nif __name__ == \"__main__\":\n    main()